import { a as addLoc, b as append, c as assign, d as children, e as claimElement, f as claimText, g as createElement, h as createText, i as detachNode, j as init, k as insert, l as protoDev, m as addListener, n as removeListener, o as setData, p as setAttribute, q as createComment, r as flush, s as groupOutros, t as removeFromStore, u as wrapTransition, v as getSpreadUpdate, w as blankObject, x as _differs, y as _differsImmutable, z as get, A as on, B as fire } from './chunk.18badf4c.js';

/* src/components/Nav.html generated by Svelte v2.15.3 */

const file = "src/components/Nav.html";

function create_main_fragment(component, ctx) {
	var div4, div3, img, text0, div0, a0, text1, div0_class_value, text2, div1, a1, text3, div1_class_value, text4, div2, a2, text5, div2_class_value;

	return {
		c: function create() {
			div4 = createElement("div");
			div3 = createElement("div");
			img = createElement("img");
			text0 = createText("\n\t\t");
			div0 = createElement("div");
			a0 = createElement("a");
			text1 = createText("Home");
			text2 = createText("\n\t\t");
			div1 = createElement("div");
			a1 = createElement("a");
			text3 = createText("Foo");
			text4 = createText("\n\t\t");
			div2 = createElement("div");
			a2 = createElement("a");
			text5 = createText("Bar");
			this.h();
		},

		l: function claim(nodes) {
			div4 = claimElement(nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div3 = claimElement(div4_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			img = claimElement(div3_nodes, "IMG", { alt: true, src: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detachNode);
			text0 = claimText(div3_nodes, "\n\t\t");

			div0 = claimElement(div3_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			a0 = claimElement(div0_nodes, "A", { href: true, class: true }, false);
			var a0_nodes = children(a0);

			text1 = claimText(a0_nodes, "Home");
			a0_nodes.forEach(detachNode);
			div0_nodes.forEach(detachNode);
			text2 = claimText(div3_nodes, "\n\t\t");

			div1 = claimElement(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			a1 = claimElement(div1_nodes, "A", { href: true, class: true }, false);
			var a1_nodes = children(a1);

			text3 = claimText(a1_nodes, "Foo");
			a1_nodes.forEach(detachNode);
			div1_nodes.forEach(detachNode);
			text4 = claimText(div3_nodes, "\n\t\t");

			div2 = claimElement(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			a2 = claimElement(div2_nodes, "A", { href: true, class: true }, false);
			var a2_nodes = children(a2);

			text5 = claimText(a2_nodes, "Bar");
			a2_nodes.forEach(detachNode);
			div2_nodes.forEach(detachNode);
			div3_nodes.forEach(detachNode);
			div4_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			img.alt = "Planet";
			img.src = "planet-earth.png";
			img.className = "svelte-115u5ln";
			addLoc(img, file, 2, 2, 41);
			a0.href = ".";
			a0.className = "svelte-115u5ln";
			addLoc(a0, file, 3, 69, 152);
			div0.className = div0_class_value = "link-wrapper " + (ctx.segment === ctx.undefined ? 'current' : '') + " svelte-115u5ln";
			addLoc(div0, file, 3, 2, 85);
			a1.href = "foo";
			a1.className = "svelte-115u5ln";
			addLoc(a1, file, 4, 65, 244);
			div1.className = div1_class_value = "link-wrapper " + (ctx.segment === 'foo' ? 'current' : '') + " svelte-115u5ln";
			addLoc(div1, file, 4, 2, 181);
			a2.href = "bar";
			a2.className = "svelte-115u5ln";
			addLoc(a2, file, 5, 65, 337);
			div2.className = div2_class_value = "link-wrapper " + (ctx.segment === 'bar' ? 'current' : '') + " svelte-115u5ln";
			addLoc(div2, file, 5, 2, 274);
			div3.className = "links svelte-115u5ln";
			addLoc(div3, file, 1, 1, 19);
			div4.className = "nav svelte-115u5ln";
			addLoc(div4, file, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, img);
			append(div3, text0);
			append(div3, div0);
			append(div0, a0);
			append(a0, text1);
			append(div3, text2);
			append(div3, div1);
			append(div1, a1);
			append(a1, text3);
			append(div3, text4);
			append(div3, div2);
			append(div2, a2);
			append(a2, text5);
		},

		p: function update(changed, ctx) {
			if ((changed.segment || changed.undefined) && div0_class_value !== (div0_class_value = "link-wrapper " + (ctx.segment === ctx.undefined ? 'current' : '') + " svelte-115u5ln")) {
				div0.className = div0_class_value;
			}

			if ((changed.segment) && div1_class_value !== (div1_class_value = "link-wrapper " + (ctx.segment === 'foo' ? 'current' : '') + " svelte-115u5ln")) {
				div1.className = div1_class_value;
			}

			if ((changed.segment) && div2_class_value !== (div2_class_value = "link-wrapper " + (ctx.segment === 'bar' ? 'current' : '') + " svelte-115u5ln")) {
				div2.className = div2_class_value;
			}
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(div4);
			}
		}
	};
}

function Nav(options) {
	this._debugName = '<Nav>';
	if (!options || (!options.target && !options.root)) {
		throw new Error("'target' is a required option");
	}

	init(this, options);
	this._state = assign({ undefined : undefined }, options.data);
	if (!('segment' in this._state)) console.warn("<Nav> was created without expected data property 'segment'");
	this._intro = true;

	this._fragment = create_main_fragment(this, this._state);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._mount(options.target, options.anchor);
	}
}

assign(Nav.prototype, protoDev);

Nav.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

function fade ( node, ref ) {
	var delay = ref.delay; if ( delay === void 0 ) delay = 0;
	var duration = ref.duration; if ( duration === void 0 ) duration = 400;

	var o = +getComputedStyle( node ).opacity;

	return {
		delay: delay,
		duration: duration,
		css: function (t) { return ("opacity: " + (t * o)); }
	};
}

/* src/components/Button.html generated by Svelte v2.15.3 */

const file$1 = "src/components/Button.html";

function create_main_fragment$1(component, ctx) {
	var button, text, button_class_value;

	function click_handler(event) {
		component.fire("click", event);
	}

	return {
		c: function create() {
			button = createElement("button");
			text = createText(ctx.text);
			this.h();
		},

		l: function claim(nodes) {
			button = claimElement(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			text = claimText(button_nodes, ctx.text);
			button_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			addListener(button, "click", click_handler);
			button.className = button_class_value = "" + (ctx.block ? 'block' : '') + " svelte-kt50x5";
			addLoc(button, file$1, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert(target, button, anchor);
			append(button, text);
		},

		p: function update(changed, ctx) {
			if (changed.text) {
				setData(text, ctx.text);
			}

			if ((changed.block) && button_class_value !== (button_class_value = "" + (ctx.block ? 'block' : '') + " svelte-kt50x5")) {
				button.className = button_class_value;
			}
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(button);
			}

			removeListener(button, "click", click_handler);
		}
	};
}

function Button(options) {
	this._debugName = '<Button>';
	if (!options || (!options.target && !options.root)) {
		throw new Error("'target' is a required option");
	}

	init(this, options);
	this._state = assign({}, options.data);
	if (!('block' in this._state)) console.warn("<Button> was created without expected data property 'block'");
	if (!('text' in this._state)) console.warn("<Button> was created without expected data property 'text'");
	this._intro = true;

	this._fragment = create_main_fragment$1(this, this._state);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._mount(options.target, options.anchor);
	}
}

assign(Button.prototype, protoDev);

Button.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* src/components/Input.html generated by Svelte v2.15.3 */

const file$2 = "src/components/Input.html";

function create_main_fragment$2(component, ctx) {
	var input;

	return {
		c: function create() {
			input = createElement("input");
			this.h();
		},

		l: function claim(nodes) {
			input = claimElement(nodes, "INPUT", { type: true, placeholder: true, class: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			setAttribute(input, "type", ctx.type);
			input.placeholder = ctx.placeholder;
			input.className = "svelte-oklsfp";
			addLoc(input, file$2, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert(target, input, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.type) {
				setAttribute(input, "type", ctx.type);
			}

			if (changed.placeholder) {
				input.placeholder = ctx.placeholder;
			}
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(input);
			}
		}
	};
}

function Input(options) {
	this._debugName = '<Input>';
	if (!options || (!options.target && !options.root)) {
		throw new Error("'target' is a required option");
	}

	init(this, options);
	this._state = assign({}, options.data);
	if (!('type' in this._state)) console.warn("<Input> was created without expected data property 'type'");
	if (!('placeholder' in this._state)) console.warn("<Input> was created without expected data property 'placeholder'");
	this._intro = true;

	this._fragment = create_main_fragment$2(this, this._state);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._mount(options.target, options.anchor);
	}
}

assign(Input.prototype, protoDev);

Input.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* src/components/Login.html generated by Svelte v2.15.3 */



const file$3 = "src/components/Login.html";

function create_main_fragment$3(component, ctx) {
	var if_block_anchor;

	var if_block = (!ctx.$loggedIn) && create_if_block(component, ctx);

	return {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = createComment();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = createComment();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (!ctx.$loggedIn) {
				if (!if_block) {
					if_block = create_if_block(component, ctx);
					if_block.c();
				}
				if_block.i(if_block_anchor.parentNode, if_block_anchor);
			} else if (if_block) {
				groupOutros();
				if_block.o(function() {
					if_block.d(1);
					if_block = null;
				});
			}
		},

		d: function destroy(detach) {
			if (if_block) if_block.d(detach);
			if (detach) {
				detachNode(if_block_anchor);
			}
		}
	};
}

// (1:0) {#if !$loggedIn}
function create_if_block(component, ctx) {
	var div3, div2, h1, text0, text1, div0, text2, div1, text3, div3_outro, current;

	var input0_initial_data = {
	 	type: "text",
	 	placeholder: "Användarnamn"
	 };
	var input0 = new Input({
		root: component.root,
		store: component.store,
		data: input0_initial_data
	});

	var input1_initial_data = {
	 	type: "password",
	 	placeholder: "Lösenord"
	 };
	var input1 = new Input({
		root: component.root,
		store: component.store,
		data: input1_initial_data
	});

	var button_initial_data = { text: "Logga in", block: true };
	var button = new Button({
		root: component.root,
		store: component.store,
		data: button_initial_data
	});

	button.on("click", function(event) {
		component.store.set({ loggedIn: true });
	});

	return {
		c: function create() {
			div3 = createElement("div");
			div2 = createElement("div");
			h1 = createElement("h1");
			text0 = createText("Logga in");
			text1 = createText("\n    ");
			div0 = createElement("div");
			input0._fragment.c();
			text2 = createText("\n    ");
			div1 = createElement("div");
			input1._fragment.c();
			text3 = createText("\n    ");
			button._fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div3 = claimElement(nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			div2 = claimElement(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			h1 = claimElement(div2_nodes, "H1", {}, false);
			var h1_nodes = children(h1);

			text0 = claimText(h1_nodes, "Logga in");
			h1_nodes.forEach(detachNode);
			text1 = claimText(div2_nodes, "\n    ");

			div0 = claimElement(div2_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			input0._fragment.l(div0_nodes);
			div0_nodes.forEach(detachNode);
			text2 = claimText(div2_nodes, "\n    ");

			div1 = claimElement(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			input1._fragment.l(div1_nodes);
			div1_nodes.forEach(detachNode);
			text3 = claimText(div2_nodes, "\n    ");
			button._fragment.l(div2_nodes);
			div2_nodes.forEach(detachNode);
			div3_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			addLoc(h1, file$3, 3, 4, 105);
			div0.className = "input-wrapper svelte-jq8s65";
			addLoc(div0, file$3, 4, 4, 127);
			div1.className = "input-wrapper svelte-jq8s65";
			addLoc(div1, file$3, 5, 4, 212);
			div2.className = "login-card svelte-jq8s65";
			addLoc(div2, file$3, 2, 2, 76);
			div3.className = "login-container svelte-jq8s65";
			addLoc(div3, file$3, 1, 0, 17);
		},

		m: function mount(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div2);
			append(div2, h1);
			append(h1, text0);
			append(div2, text1);
			append(div2, div0);
			input0._mount(div0, null);
			append(div2, text2);
			append(div2, div1);
			input1._mount(div1, null);
			append(div2, text3);
			button._mount(div2, null);
			current = true;
		},

		i: function intro(target, anchor) {
			if (current) return;
			if (div3_outro) div3_outro.abort(1);
			this.m(target, anchor);
		},

		o: function outro(outrocallback) {
			if (!current) return;

			div3_outro = wrapTransition(component, div3, fade, {duration: 100}, false);
			div3_outro.run(0, outrocallback);

			current = false;
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(div3);
			}

			input0.destroy();
			input1.destroy();
			button.destroy();
			if (detach) {
				if (div3_outro) div3_outro.abort();
			}
		}
	};
}

function Login(options) {
	this._debugName = '<Login>';
	if (!options || (!options.target && !options.root)) {
		throw new Error("'target' is a required option");
	}
	if (!options.store) {
		throw new Error("<Login> references store properties, but no store was provided");
	}

	init(this, options);
	this._state = assign(this.store._init(["loggedIn"]), options.data);
	this.store._add(this, ["loggedIn"]);
	if (!('$loggedIn' in this._state)) console.warn("<Login> was created without expected data property '$loggedIn'");
	this._intro = true;

	this._handlers.destroy = [removeFromStore];

	this._fragment = create_main_fragment$3(this, this._state);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._mount(options.target, options.anchor);

		flush(this);
	}
}

assign(Login.prototype, protoDev);

Login.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* src/routes/_layout.html generated by Svelte v2.15.3 */

const file$4 = "src/routes/_layout.html";

function create_main_fragment$4(component, ctx) {
	var text0, text1, div1, div0;

	var nav_initial_data = { segment: ctx.child.segment };
	var nav = new Nav({
		root: component.root,
		store: component.store,
		data: nav_initial_data
	});

	var login = new Login({
		root: component.root,
		store: component.store
	});

	var switch_instance_spread_levels = [
		ctx.child.props
	];

	var switch_value = ctx.child.component;

	function switch_props(ctx) {
		var switch_instance_initial_data = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_initial_data = assign(switch_instance_initial_data, switch_instance_spread_levels[i]);
		}
		return {
			root: component.root,
			store: component.store,
			data: switch_instance_initial_data
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c: function create() {
			nav._fragment.c();
			text0 = createText("\n\n");
			login._fragment.c();
			text1 = createText("\n\n");
			div1 = createElement("div");
			div0 = createElement("div");
			if (switch_instance) switch_instance._fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			nav._fragment.l(nodes);
			text0 = claimText(nodes, "\n\n");
			login._fragment.l(nodes);
			text1 = claimText(nodes, "\n\n");

			div1 = claimElement(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claimElement(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if (switch_instance) switch_instance._fragment.l(div0_nodes);
			div0_nodes.forEach(detachNode);
			div1_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			div0.className = "main svelte-iw4qk";
			addLoc(div0, file$4, 5, 1, 68);
			div1.className = "container svelte-iw4qk";
			addLoc(div1, file$4, 4, 0, 43);
		},

		m: function mount(target, anchor) {
			nav._mount(target, anchor);
			insert(target, text0, anchor);
			login._mount(target, anchor);
			insert(target, text1, anchor);
			insert(target, div1, anchor);
			append(div1, div0);

			if (switch_instance) {
				switch_instance._mount(div0, null);
			}
		},

		p: function update(changed, ctx) {
			var nav_changes = {};
			if (changed.child) nav_changes.segment = ctx.child.segment;
			nav._set(nav_changes);

			var switch_instance_changes = changed.child ? getSpreadUpdate(switch_instance_spread_levels, [
				ctx.child.props
			]) : {};

			if (switch_value !== (switch_value = ctx.child.component)) {
				if (switch_instance) {
					switch_instance.destroy();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance._fragment.c();
					switch_instance._mount(div0, null);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance._set(switch_instance_changes);
			}
		},

		d: function destroy(detach) {
			nav.destroy(detach);
			if (detach) {
				detachNode(text0);
			}

			login.destroy(detach);
			if (detach) {
				detachNode(text1);
				detachNode(div1);
			}

			if (switch_instance) switch_instance.destroy();
		}
	};
}

function Layout(options) {
	this._debugName = '<Layout>';
	if (!options || (!options.target && !options.root)) {
		throw new Error("'target' is a required option");
	}

	init(this, options);
	this._state = assign({}, options.data);
	if (!('child' in this._state)) console.warn("<Layout> was created without expected data property 'child'");
	this._intro = true;

	this._fragment = create_main_fragment$4(this, this._state);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._mount(options.target, options.anchor);

		flush(this);
	}
}

assign(Layout.prototype, protoDev);

Layout.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

/* src/routes/_error.html generated by Svelte v2.15.3 */

const file$5 = "src/routes/_error.html";

function create_main_fragment$5(component, ctx) {
	var title_value, text0, h1, text1, text2, p, text3_value = ctx.error.message, text3, text4, if_block_anchor;

	document.title = title_value = ctx.status;

	var if_block = (ctx.error.stack) && create_if_block$1(component, ctx);

	return {
		c: function create() {
			text0 = createText("\n\n");
			h1 = createElement("h1");
			text1 = createText(ctx.status);
			text2 = createText("\n\n");
			p = createElement("p");
			text3 = createText(text3_value);
			text4 = createText("\n\n");
			if (if_block) if_block.c();
			if_block_anchor = createComment();
			this.h();
		},

		l: function claim(nodes) {
			text0 = claimText(nodes, "\n\n");

			h1 = claimElement(nodes, "H1", {}, false);
			var h1_nodes = children(h1);

			text1 = claimText(h1_nodes, ctx.status);
			h1_nodes.forEach(detachNode);
			text2 = claimText(nodes, "\n\n");

			p = claimElement(nodes, "P", {}, false);
			var p_nodes = children(p);

			text3 = claimText(p_nodes, text3_value);
			p_nodes.forEach(detachNode);
			text4 = claimText(nodes, "\n\n");
			if (if_block) if_block.l(nodes);
			if_block_anchor = createComment();
			this.h();
		},

		h: function hydrate() {
			addLoc(h1, file$5, 4, 0, 55);
			addLoc(p, file$5, 6, 0, 74);
		},

		m: function mount(target, anchor) {
			insert(target, text0, anchor);
			insert(target, h1, anchor);
			append(h1, text1);
			insert(target, text2, anchor);
			insert(target, p, anchor);
			append(p, text3);
			insert(target, text4, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.status) && title_value !== (title_value = ctx.status)) {
				document.title = title_value;
			}

			if (changed.status) {
				setData(text1, ctx.status);
			}

			if ((changed.error) && text3_value !== (text3_value = ctx.error.message)) {
				setData(text3, text3_value);
			}

			if (ctx.error.stack) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$1(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(text0);
				detachNode(h1);
				detachNode(text2);
				detachNode(p);
				detachNode(text4);
			}

			if (if_block) if_block.d(detach);
			if (detach) {
				detachNode(if_block_anchor);
			}
		}
	};
}

// (9:0) {#if dev && error.stack}
function create_if_block$1(component, ctx) {
	var pre, text_value = ctx.error.stack, text;

	return {
		c: function create() {
			pre = createElement("pre");
			text = createText(text_value);
			this.h();
		},

		l: function claim(nodes) {
			pre = claimElement(nodes, "PRE", {}, false);
			var pre_nodes = children(pre);

			text = claimText(pre_nodes, text_value);
			pre_nodes.forEach(detachNode);
			this.h();
		},

		h: function hydrate() {
			addLoc(pre, file$5, 9, 1, 124);
		},

		m: function mount(target, anchor) {
			insert(target, pre, anchor);
			append(pre, text);
		},

		p: function update(changed, ctx) {
			if ((changed.error) && text_value !== (text_value = ctx.error.stack)) {
				setData(text, text_value);
			}
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(pre);
			}
		}
	};
}

function Error$1(options) {
	this._debugName = '<Error>';
	if (!options || (!options.target && !options.root)) {
		throw new Error$1("'target' is a required option");
	}

	init(this, options);
	this._state = assign({}, options.data);
	if (!('status' in this._state)) console.warn("<Error> was created without expected data property 'status'");
	if (!('error' in this._state)) console.warn("<Error> was created without expected data property 'error'");
	this._intro = true;

	this._fragment = create_main_fragment$5(this, this._state);

	if (options.target) {
		var nodes = children(options.target);
		options.hydrate ? this._fragment.l(nodes) : this._fragment.c();
		nodes.forEach(detachNode);
		this._mount(options.target, options.anchor);
	}
}

assign(Error$1.prototype, protoDev);

Error$1.prototype._checkReadOnly = function _checkReadOnly(newState) {
};

// This file is generated by Sapper — do not edit it!

function goto(href, opts = { replaceState: false }) {
    const target$$1 = select_route(new URL(href, document.baseURI));
    if (target$$1) {
        _history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
        return navigate(target$$1, null).then(() => { });
    }
    location.href = href;
    return new Promise(f => { }); // never resolves
}

const ignore = [];
const components = [
	{
		js: () => import("./index.85599372.js"),
		css: ["index.85599372.css"]
	},
	{
		js: () => import("./bar.8de5b496.js"),
		css: []
	},
	{
		js: () => import("./foo.5ba113ab.js"),
		css: []
	}
];
const pages = [
	{
		// index.html
		pattern: /^\/?$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// bar.html
		pattern: /^\/bar\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// foo.html
		pattern: /^\/foo\/?$/,
		parts: [
			{ i: 2 }
		]
	}
];
let ready = false;
let root_component;
let segments = [];
let current_token;
let root_preload;
let root_data;
const root_props = {
    path: null,
    params: null,
    query: null,
    child: {
        segment: null,
        component: null,
        props: {}
    }
};
let prefetching = null;
function set_prefetching(href, promise) {
    prefetching = { href, promise };
}
let store;
function set_store(fn) {
    store = fn(initial_data.store);
}
let target;
function set_target(element) {
    target = element;
}
let uid = 1;
function set_uid(n) {
    uid = n;
}
let cid;
function set_cid(n) {
    cid = n;
}
const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;
const _history = typeof history !== 'undefined' ? history : {
    pushState: (state, title, href) => { },
    replaceState: (state, title, href) => { },
    scrollRestoration: ''
};
const scroll_history = {};
function select_route(url) {
    if (url.origin !== location.origin)
        return null;
    if (!url.pathname.startsWith(initial_data.baseUrl))
        return null;
    const path = url.pathname.slice(initial_data.baseUrl.length);
    // avoid accidental clashes between server routes and pages
    if (ignore.some(pattern => pattern.test(path)))
        return;
    for (let i = 0; i < pages.length; i += 1) {
        const page = pages[i];
        const match = page.pattern.exec(path);
        if (match) {
            const query = {};
            if (url.search.length > 0) {
                url.search.slice(1).split('&').forEach(searchParam => {
                    const [, key, value] = /([^=]+)(?:=(.*))?/.exec(searchParam);
                    query[key] = decodeURIComponent((value || '').replace(/\+/g, ' '));
                });
            }
            return { url, path, page, match, query };
        }
    }
}
function scroll_state() {
    return {
        x: scrollX,
        y: scrollY
    };
}
function navigate(target, id, noscroll = false) {
    if (id) {
        // popstate or initial navigation
        cid = id;
    }
    else {
        const current_scroll = scroll_state();
        // clicked on a link. preserve scroll state
        scroll_history[cid] = current_scroll;
        id = cid = ++uid;
        scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
    }
    cid = id;
    if (root_component) {
        root_component.set({ preloading: true });
    }
    const loaded = prefetching && prefetching.href === target.url.href ?
        prefetching.promise :
        prepare_page(target);
    prefetching = null;
    const token = current_token = {};
    return loaded.then(({ redirect, data, nullable_depth }) => {
        if (redirect) {
            return goto(redirect.location, { replaceState: true });
        }
        render(data, nullable_depth, scroll_history[id], token);
        if (document.activeElement)
            document.activeElement.blur();
    });
}
function render(data, nullable_depth, scroll, token) {
    if (current_token !== token)
        return;
    if (root_component) {
        // first, clear out highest-level root component
        let level = data.child;
        for (let i = 0; i < nullable_depth; i += 1) {
            if (i === nullable_depth)
                break;
            level = level.props.child;
        }
        const { component } = level;
        level.component = null;
        root_component.set({ child: data.child });
        // then render new stuff
        level.component = component;
        root_component.set(data);
    }
    else {
        // first load — remove SSR'd <head> contents
        const start = document.querySelector('#sapper-head-start');
        const end = document.querySelector('#sapper-head-end');
        if (start && end) {
            while (start.nextSibling !== end)
                detach(start.nextSibling);
            detach(start);
            detach(end);
        }
        Object.assign(data, root_data);
        root_component = new Layout({
            target,
            data,
            store,
            hydrate: true
        });
    }
    if (scroll) {
        scrollTo(scroll.x, scroll.y);
    }
    Object.assign(root_props, data);
    ready = true;
}
function prepare_page(target) {
    const { page, path, query } = target;
    const new_segments = path.split('/').filter(Boolean);
    let changed_from = 0;
    while (segments[changed_from] &&
        new_segments[changed_from] &&
        segments[changed_from] === new_segments[changed_from])
        changed_from += 1;
    let redirect = null;
    let error = null;
    const preload_context = {
        store,
        fetch: (url, opts) => fetch(url, opts),
        redirect: (statusCode, location) => {
            if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
                throw new Error(`Conflicting redirects`);
            }
            redirect = { statusCode, location };
        },
        error: (statusCode, message) => {
            error = { statusCode, message };
        }
    };
    if (!root_preload) {
        root_preload = Layout.preload
            ? initial_data.preloaded[0] || Layout.preload.call(preload_context, {
                path,
                query,
                params: {}
            })
            : {};
    }
    return Promise.all(page.parts.map((part, i) => {
        if (i < changed_from)
            return null;
        if (!part)
            return null;
        return load_component(components[part.i]).then(Component => {
            const req = {
                path,
                query,
                params: part.params ? part.params(target.match) : {}
            };
            let preloaded;
            if (ready || !initial_data.preloaded[i + 1]) {
                preloaded = Component.preload
                    ? Component.preload.call(preload_context, req)
                    : {};
            }
            else {
                preloaded = initial_data.preloaded[i + 1];
            }
            return Promise.resolve(preloaded).then(preloaded => {
                return { Component, preloaded };
            });
        });
    })).catch(err => {
        error = { statusCode: 500, message: err };
        return [];
    }).then(results => {
        if (root_data) {
            return results;
        }
        else {
            return Promise.resolve(root_preload).then(value => {
                root_data = value;
                return results;
            });
        }
    }).then(results => {
        if (redirect) {
            return { redirect };
        }
        segments = new_segments;
        const get_params = page.parts[page.parts.length - 1].params || (() => ({}));
        const params = get_params(target.match);
        if (error) {
            const props = {
                path,
                query,
                params,
                error: typeof error.message === 'string' ? new Error(error.message) : error.message,
                status: error.statusCode
            };
            return {
                data: Object.assign({}, props, {
                    preloading: false,
                    child: {
                        component: Error$1,
                        props
                    }
                })
            };
        }
        const props = { path, query };
        const data = {
            path,
            preloading: false,
            child: Object.assign({}, root_props.child, {
                segment: segments[0]
            })
        };
        if (changed(query, root_props.query))
            data.query = query;
        if (changed(params, root_props.params))
            data.params = params;
        let level = data.child;
        let nullable_depth = 0;
        for (let i = 0; i < page.parts.length; i += 1) {
            const part = page.parts[i];
            if (!part)
                continue;
            const get_params = part.params || (() => ({}));
            if (i < changed_from) {
                level.props.path = path;
                level.props.query = query;
                level.props.child = Object.assign({}, level.props.child);
                nullable_depth += 1;
            }
            else {
                level.component = results[i].Component;
                level.props = Object.assign({}, level.props, props, {
                    params: get_params(target.match),
                }, results[i].preloaded);
                level.props.child = {};
            }
            level = level.props.child;
            level.segment = segments[i + 1];
        }
        return { data, nullable_depth };
    });
}
function load_css(chunk) {
    const href = `client/${chunk}`;
    if (document.querySelector(`link[href="${href}"]`))
        return;
    return new Promise((fulfil, reject) => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = href;
        link.onload = () => fulfil();
        link.onerror = reject;
        document.head.appendChild(link);
    });
}
function load_component(component) {
    // TODO this is temporary — once placeholders are
    // always rewritten, scratch the ternary
    const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
    promises.unshift(component.js());
    return Promise.all(promises).then(values => values[0].default);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function changed(a, b) {
    return JSON.stringify(a) !== JSON.stringify(b);
}

function prefetch(href) {
    const target$$1 = select_route(new URL(href, document.baseURI));
    if (target$$1 && (!prefetching || href !== prefetching.href)) {
        set_prefetching(href, prepare_page(target$$1));
    }
}

function start(opts) {
    if ('scrollRestoration' in _history) {
        _history.scrollRestoration = 'manual';
    }
    set_target(opts.target);
    if (opts.store)
        set_store(opts.store);
    addEventListener('click', handle_click);
    addEventListener('popstate', handle_popstate);
    // prefetch
    addEventListener('touchstart', trigger_prefetch);
    addEventListener('mousemove', handle_mousemove);
    return Promise.resolve().then(() => {
        const { hash, href } = location;
        const deep_linked = hash && document.getElementById(hash.slice(1));
        scroll_history[uid] = deep_linked ?
            { x: 0, y: deep_linked.getBoundingClientRect().top } :
            scroll_state();
        _history.replaceState({ id: uid }, '', href);
        if (!initial_data.error) {
            const target$$1 = select_route(new URL(location.href));
            if (target$$1)
                return navigate(target$$1, uid);
        }
    });
}
let mousemove_timeout;
function handle_mousemove(event) {
    clearTimeout(mousemove_timeout);
    mousemove_timeout = setTimeout(() => {
        trigger_prefetch(event);
    }, 20);
}
function trigger_prefetch(event) {
    const a = find_anchor(event.target);
    if (!a || a.rel !== 'prefetch')
        return;
    prefetch(a.href);
}
function handle_click(event) {
    // Adapted from https://github.com/visionmedia/page.js
    // MIT license https://github.com/visionmedia/page.js#license
    if (which(event) !== 1)
        return;
    if (event.metaKey || event.ctrlKey || event.shiftKey)
        return;
    if (event.defaultPrevented)
        return;
    const a = find_anchor(event.target);
    if (!a)
        return;
    if (!a.href)
        return;
    // check if link is inside an svg
    // in this case, both href and target are always inside an object
    const svg = typeof a.href === 'object' && a.href.constructor.name === 'SVGAnimatedString';
    const href = String(svg ? a.href.baseVal : a.href);
    if (href === location.href) {
        event.preventDefault();
        return;
    }
    // Ignore if tag has
    // 1. 'download' attribute
    // 2. rel='external' attribute
    if (a.hasAttribute('download') || a.getAttribute('rel') === 'external')
        return;
    // Ignore if <a> has a target
    if (svg ? a.target.baseVal : a.target)
        return;
    const url = new URL(href);
    // Don't handle hash changes
    if (url.pathname === location.pathname && url.search === location.search)
        return;
    const target$$1 = select_route(url);
    if (target$$1) {
        const noscroll = a.hasAttribute('sapper-noscroll');
        navigate(target$$1, null, noscroll);
        event.preventDefault();
        _history.pushState({ id: cid }, '', url.href);
    }
}
function which(event) {
    return event.which === null ? event.button : event.which;
}
function find_anchor(node) {
    while (node && node.nodeName.toUpperCase() !== 'A')
        node = node.parentNode; // SVG <a> elements have a lowercase name
    return node;
}
function handle_popstate(event) {
    scroll_history[cid] = scroll_state();
    if (event.state) {
        const url = new URL(location.href);
        const target$$1 = select_route(url);
        if (target$$1) {
            navigate(target$$1, event.state.id);
        }
        else {
            location.href = location.href;
        }
    }
    else {
        // hashchange
        set_uid(uid + 1);
        set_cid(uid);
        _history.replaceState({ id: cid }, '', location.href);
    }
}


if (typeof window !== 'undefined') {
	import("./sapper-dev-client.c1ed07a9.js").then(client => {
		client.connect(10000);
	});
}

function Store(state, options) {
	this._handlers = {};
	this._dependents = [];

	this._computed = blankObject();
	this._sortedComputedProperties = [];

	this._state = assign({}, state);
	this._differs = options && options.immutable ? _differsImmutable : _differs;
}

assign(Store.prototype, {
	_add(component, props) {
		this._dependents.push({
			component: component,
			props: props
		});
	},

	_init(props) {
		const state = {};
		for (let i = 0; i < props.length; i += 1) {
			const prop = props[i];
			state['$' + prop] = this._state[prop];
		}
		return state;
	},

	_remove(component) {
		let i = this._dependents.length;
		while (i--) {
			if (this._dependents[i].component === component) {
				this._dependents.splice(i, 1);
				return;
			}
		}
	},

	_set(newState, changed) {
		const previous = this._state;
		this._state = assign(assign({}, previous), newState);

		for (let i = 0; i < this._sortedComputedProperties.length; i += 1) {
			this._sortedComputedProperties[i].update(this._state, changed);
		}

		this.fire('state', {
			changed,
			previous,
			current: this._state
		});

		this._dependents
			.filter(dependent => {
				const componentState = {};
				let dirty = false;

				for (let j = 0; j < dependent.props.length; j += 1) {
					const prop = dependent.props[j];
					if (prop in changed) {
						componentState['$' + prop] = this._state[prop];
						dirty = true;
					}
				}

				if (dirty) {
					dependent.component._stage(componentState);
					return true;
				}
			})
			.forEach(dependent => {
				dependent.component.set({});
			});

		this.fire('update', {
			changed,
			previous,
			current: this._state
		});
	},

	_sortComputedProperties() {
		const computed = this._computed;
		const sorted = this._sortedComputedProperties = [];
		const visited = blankObject();
		let currentKey;

		function visit(key) {
			const c = computed[key];

			if (c) {
				c.deps.forEach(dep => {
					if (dep === currentKey) {
						throw new Error(`Cyclical dependency detected between ${dep} <-> ${key}`);
					}

					visit(dep);
				});

				if (!visited[key]) {
					visited[key] = true;
					sorted.push(c);
				}
			}
		}

		for (const key in this._computed) {
			visit(currentKey = key);
		}
	},

	compute(key, deps, fn) {
		let value;

		const c = {
			deps,
			update: (state, changed, dirty) => {
				const values = deps.map(dep => {
					if (dep in changed) dirty = true;
					return state[dep];
				});

				if (dirty) {
					const newValue = fn.apply(null, values);
					if (this._differs(newValue, value)) {
						value = newValue;
						changed[key] = true;
						state[key] = value;
					}
				}
			}
		};

		this._computed[key] = c;
		this._sortComputedProperties();

		const state = assign({}, this._state);
		const changed = {};
		c.update(state, changed, true);
		this._set(state, changed);
	},

	fire,

	get,

	on,

	set(newState) {
		const oldState = this._state;
		const changed = this._changed = {};
		let dirty = false;

		for (const key in newState) {
			if (this._computed[key]) throw new Error(`'${key}' is a read-only computed property`);
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._set(newState, changed);
	}
});

start({
	target: document.querySelector('#sapper'),
	store: data => {
    // `data` is whatever was in the server-side store
    return new Store(data);
  }
});
//# sourceMappingURL=client.fe2fc68f.js.map
